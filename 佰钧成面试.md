###react 虚拟dom 理解和介绍

####[虚拟dom]('https://github.com/Matt-Esch/virtual-dom')
>原因原始大型数据如果使用innerhtml直接在实际dom上操作随着应用程序的复杂而难以维护性能降低，mvc架构mvp架构的出现都是希望从代码组织方式来降低维护复杂难度，你需要的dom还是需要操作只是换了个地方，既然state改变要操作对应的DOM元素，那么为什么不做一个东西可以让视图和状态进行绑定，状态改变了视图自动更新。
>这是MVVM模式出现，只要在模板中声明视图组件是如何绑定的，双向绑定引警就会在状态钢芯的售后自动更新视图这种模式大大的减少代码中的视图更新逻辑
>还有一个非常直观的方法，可以大大降低视图更新的操作：一旦状态发生了变化，就用模版引擎重新渲染整个视图，然后用新的视图更换掉旧的视图其实 Virtual DOM 就是这么做的，只是加了一些特别的步骤来避免了整棵 DOM 树变更。
#####实现
>   
    步骤一：用JS对象模拟DOM树
    步骤二：比较两棵虚拟DOM树的差异
    步骤三：把差异应用到真正的DOM树上
》如一个dom 对象
> 
    <ul id='list'>
    <li class='item'>Item 1</li>
    <li class='item'>Item 2</li>
    <li class='item'>Item 3</li>
    </ul>
》在用js对象写出来
> 
    var element = {
        tagName: 'ul', // 节点标签名
        props: { // DOM的属性，用一个对象存储键值对
            id: 'list'
        },
        children: [ // 该节点的子节点
            {tagName: 'li', props: {class: 'item'}, children: ["Item 1"]},
            {tagName: 'li', props: {class: 'item'}, children: ["Item 2"]},
            {tagName: 'li', props: {class: 'item'}, children: ["Item 3"]},
        ]
    }
》那么我们就可以来用element来构建一颗真正的DOM树
>当状态发生改变时
  用新渲染的对象树去和旧的树进行对比，记录这两棵树差异。记录下来的不同就是我们需要对页面真正的 DOM 操作，然后把它们应用在真正的 DOM 树上，页面就变更了。这样就可以做到：视图的结构确实是整个全新渲染了，但是最后操作DOM的时候确实只变更有不同的地方。
####js创建一个对象
>



   